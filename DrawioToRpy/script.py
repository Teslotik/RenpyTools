# TODO argparse
# TODO Если есть entry, считать эту метку началом

import sys

# diagram = r'./test.drawio'
# diagram = r'./structure.drawio'
progname, diagram = sys.argv

template = '''
# AUTO-GENERATED BY TESLOTIK's draw.io to rpy generator
# LINK: https://github.com/teslotik
# WARNING! ANY CHANGES WILL BE REMOVED AFTER NEW GENERATION

init python:
    class Transition:
        def __init__(self, source: str, target: str, rule):
            self.source = source
            self.target = target
            self.rule = rule

    class FSTM:
        def __init__(self):
            self.state = None       # current state
            # Transitions
            self.transitions = []   # all transitions
            self.current = []       # transitions from current state

        def init(self, state: str):
            self.state = state
            self.__sync__()

        def transition(self, source: str, target: str, rule):
            transition = Transition(source, target, rule)
            self.transitions.append(transition)

        def step(self, apply, fallback = None):
            for transition in self.current:
                if not transition.rule(): continue
                self.state = transition.target
                self.__sync__()
                print('State changed to:', self.state)
                return apply(self.state)
            print('Transition not found for state:', self.state, len(self.current))
            if fallback is not None: fallback(self.state)

        def __sync__(self):
            self.current = [t for t in self.transitions if t.source == self.state]

screen fstmenu(*items):
    $ mchoice = menu(items)

default mchoice = None

label fstm_start:
    # Creating FSTM
    $ fstm = FSTM()

    # Building transitions
    {}

    # Setting start state
    $ fstm.init('{}')

    # Main loop
    while True:
        $ fstm.step(
            lambda state: renpy.call(state, from_current = True),
            lambda state: None  # TODO return
        )
'''

'''
# Example of draw.io xml format

# Block
<mxCell id="7oDNk_bg9m65Ez2jLHi6-50" value="ryt_lars2roid" style="rounded=0;whiteSpace=wrap;html=1;fontSize=12;" parent="1" vertex="1">
    <mxGeometry x="6040" y="2400" width="120" height="40" as="geometry" />
</mxCell>

# Arrow text
<mxCell id="7oDNk_bg9m65Ez2jLHi6-53" value="Приложу к его шеесвой клинок" style="edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];fontSize=12;" parent="7oDNk_bg9m65Ez2jLHi6-52" vertex="1" connectable="0">
    <mxGeometry x="0.3304" y="2" relative="1" as="geometry">
    <mxPoint x="-15" y="-2" as="offset" />
    </mxGeometry>
</mxCell>

# Arrow
<mxCell id="7oDNk_bg9m65Ez2jLHi6-52" value="" style="endArrow=classic;html=1;rounded=0;fontSize=12;" parent="1" source="7oDNk_bg9m65Ez2jLHi6-45" target="7oDNk_bg9m65Ez2jLHi6-50" edge="1">
    <mxGeometry width="50" height="50" relative="1" as="geometry">
    <mxPoint x="4820" y="2350" as="sourcePoint" />
    <mxPoint x="4870" y="2300" as="targetPoint" />
    </mxGeometry>
</mxCell>
'''

from lxml import etree
import os
import sys

class LabelTransition:
    def __init__(self):
        # NOTE Stores reference to states,
        # not as states label, but as ids in xml
        self.source = None
        self.target = None
        self.rule = None

    def __str__(self) -> str:
        return 'LabelTransition(from: {}, to: {}, rule: {})'.format(
            self.source,
            self.target,
            self.rule
        )

    def __repr__(self) -> str:
        return str(self)


class LabelState:
    def __init__(self):
        self.label = None

    def __str__(self) -> str:
        return f'LabelState(label: {self.label})'

    def __repr__(self) -> str:
        return str(self)


# -------------------------- Building connections --------------------------

states = {}         # {id: LabelState}
transitions = {}    # {id: LabelTransition}

tree = etree.parse(diagram)
root = tree.xpath(r'/mxfile/diagram/mxGraphModel/root/mxCell')
for item in root:
    ident = item.attrib.get('id')
    value = item.attrib.get('value')

    if not ident: continue
    
    if item.attrib.get('edge') == '1':
        # Arrow itself - extracting link
        # Also used in case arrow doesn't contains text
        # NOTE In case all conditions fails
        # FSTM will choose this branch as fallback
        transition = transitions.get(ident, LabelTransition())
        transition.source = item.attrib.get('source')
        transition.target = item.attrib.get('target')
        transitions.update({ident: transition})

    elif item.attrib.get('connectable') == '0':
        # Arrow text - extracting rule
        if not value: continue
        ident = item.attrib.get('parent')
        # Text stores reference to the arrow (as a parent attribute),
        # which contains links between text blocks
        transition = transitions.get(ident, LabelTransition())
        rule = value\
            .replace('&lt;', '<')\
            .replace('&gt;', '>')\
            .replace('&amp;', '&')\
            .replace('&quot;', '"')
        # Is it python or menu expression?
        if rule.startswith('$'):
            # Menu expression - string starts with reserved $ sign
            transition.rule = "mchoice == '{}'".format(rule.replace('$', ''))
        else:
            # Determinating type of the expression
            # TODO Change to better algorithm
            try:
                # Python expression
                eval(rule)
                transition.rule = rule
            except NameError:
                # Python expression - but with variables
                transition.rule = rule
            except:
                # Menu expression - Synatax error etc.
                transition.rule = f"mchoice == '{rule}'"
        transitions.update({ident: transition})

    else:
        # Text block - extracting label
        if not value: continue
        state = states.get(ident, LabelState())
        state.label = value
        states.update({ident: state})

# Trying to find states which are not referenced
nullable = set(states.values()) - set(states[t.target] for t in transitions.values())
# Using sort so result will be the same after set() is applied
nullable = sorted(nullable, key = lambda s: s.label)
if len(nullable) > 1:
    print('WARNING! Multiply entry points, choosing first:', ', '.join(s.label for s in nullable))
elif not nullable:
    print('ERROR! No entry points found! Exiting...')
    sys.exit(1)
entry = next(iter(nullable))

# -------------------------- Printing the code --------------------------

# NOTE Using two steps sort because all None rules must follows
# not empty conditions
data = sorted(transitions.values(), key = lambda t: t.rule is None)
data = sorted(data, key = lambda t: states[t.source].label)

# Building transitions
rows = []
for transition in data:
    rows.append("$ fstm.transition('{}', '{}', lambda: {})".format(
        states[transition.source].label,
        states[transition.target].label,
        (transition.rule if transition.rule else 'True')
    ))

name, extension = os.path.splitext(os.path.basename(diagram))
# TODO
# pathname = name + '.rpy'
# pathname = f'./game/narration/{name}.rpy'
pathname = f'{name}.rpy'

# TODO
# if os.path.exists(pathname):
#     print(f'ERROR! File "{pathname}" already exists, remove it first!')
#     sys.exit(1)

# Printing to file
with open(pathname, 'w', encoding = 'utf-8') as file:
    print(template.format(
        '\n    '.join(rows),
        entry.label
    ), file = file)

print('FINISHED! File saved to:', pathname)