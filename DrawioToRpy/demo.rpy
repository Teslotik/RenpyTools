
# AUTO-GENERATED BY TESLOTIK's draw.io to rpy generator
# LINK: https://github.com/teslotik
# WARNING! ANY CHANGES WILL BE REMOVED AFTER NEW GENERATION

init python:
    class Transition:
        def __init__(self, source: str, target: str, rule):
            self.source = source
            self.target = target
            self.rule = rule

    class FSTM:
        def __init__(self):
            self.state = None       # current state
            # Transitions
            self.transitions = []   # all transitions
            self.current = []       # transitions from current state

        def init(self, state: str):
            self.state = state
            self.__sync__()

        def transition(self, source: str, target: str, rule):
            transition = Transition(source, target, rule)
            self.transitions.append(transition)

        def step(self, apply, fallback = None):
            for transition in self.current:
                if not transition.rule(): continue
                self.state = transition.target
                self.__sync__()
                print('State changed to:', self.state)
                return apply(self.state)
            print('Transition not found for state:', self.state, len(self.current))
            if fallback is not None: fallback(self.state)

        def __sync__(self):
            self.current = [t for t in self.transitions if t.source == self.state]

screen fstmenu(*items):
    $ mchoice = menu(items)

default mchoice = None

label fstm_start:
    # Creating FSTM
    $ fstm = FSTM()

    # Building transitions
    $ fstm.transition('continion_end', 'ryt_kill', lambda: mchoice == 'Убить')
    $ fstm.transition('continion_end', 'ryt_deatch7', lambda: mchoice == 'Не убивать')
    $ fstm.transition('continions', 'continion_end', lambda: True)
    $ fstm.transition('entry', 'continions', lambda: prologopening_points == 1)
    $ fstm.transition('entry', 'prolog', lambda: True)
    $ fstm.transition('prolog', 'continions', lambda: True)
    $ fstm.transition('roid_liveend', 'ryt_lars_end', lambda: mchoice == 'Ларс!')
    $ fstm.transition('roid_liveend', 'ryt_roid_end', lambda: mchoice == 'Ройд!')
    $ fstm.transition('roid_liveend', 'ryt_bael_end2', lambda: mchoice == 'Баэль!')
    $ fstm.transition('roid_liveend2', 'secred_live_endblue', lambda: secretroid_points == 3)
    $ fstm.transition('roid_liveend2', 'cont', lambda: True)
    $ fstm.transition('roid_ripend', 'ryt_lars_end', lambda: mchoice == 'Ларс!')
    $ fstm.transition('roid_ripend', 'ryt_bael_end2', lambda: mchoice == 'Баэль!')
    $ fstm.transition('ryt_bael_end2', 'ryt_roidrip_end', lambda: True)
    $ fstm.transition('ryt_kill', 'roid_ripend', lambda: ppoints_roid_rip == 1)
    $ fstm.transition('ryt_kill', 'roid_liveend', lambda: True)
    $ fstm.transition('ryt_lars_end', 'roid_liveend2', lambda: True)
    $ fstm.transition('ryt_roid_end', 'roid_liveend2', lambda: True)
    $ fstm.transition('ryt_roidrip_end', 'cont', lambda: ppoints_roid_rip == 1)
    $ fstm.transition('ryt_roidrip_end', 'roid_liveend2', lambda: True)

    # Setting start state
    $ fstm.init('entry')

    # Main loop
    while True:
        $ fstm.step(
            lambda state: renpy.call(state, from_current = True),
            lambda state: None  # TODO return
        )

